testSphereInFrustrum -> Se usa para comprobar si un objecto se va a ver , si no se ve no lo pintes( No lo mandes  a gpu ). Por lo tanto comprobar en el render(De entity).
			Hay que usar el radio de la mesh ( bounding box ) para saber si se ve algun trozo o no. El centro de la caja no tiene porque ser el del objeto. ç
			Para cada vértice calculas los máximos y mínimos de cada componente(x,y,z)
			
Usar el spitfire low cuando haces render de un objeto desde lejos

OBJ parser de asignatura de infografia


---------


Collisions:
---

static_colliders : NO se mueven, así que no hay colisiones entre ellas
dynamic_colliders : Pueden colisionar entre ellas y con static_colliders

virtual onCollision(EntityCollider*) : Depende de la entidad concreta (plane, island, missil, etc) se pueden programar distintas reacciones a la colisión


---------

POOL:

Bullet bullet_pull[100]

[ b | b | b | b | b |  |  |  |  |  | ... |  ]
last = 4

Cuando tiempo de vida (ttl) es menor o igual que 0, el slot está "libre"

Para optimizar, se intentan poner todas las balas activas a la izquierda. Cuando se añade una se pone en el primer slot libre (indicador a allí). Cuando se quita una se pone en su lugar la bala de más a la derecha.

update: iterar i=0 : 4
render: render de varias de golpe (no una a una)

---

Idea camara: no sería descabellado que la posición y enfoque de la camara dependiese de una model que se multiplicase
por la de la entidad. Así se obtendría la misma posición relativa respecto la entidad todo el tiempo.


---------------
Entrega:
grafo de escena y player controller

-----
NOTA: para sacar el vector frontal de un avion
---------------

---AI---
AI controller:
    target: a quien persigue
    patruya: array de waypoints y cada vez va a uno (Patruya entre unas posiciones y otras)(Mas facil que perseguir por los lios de vectores de abajo)

    Debería valer tanto para los aliados como para los enemigos.

    Aviones de buscar y atacar , Aviones de ir a un punto y hacer algo y ya , escoltas (area de acción alrededor de una entidad)

Grafo de comportamiento (Behaviour tree):
De izquierda a derecha mas importante a menos, se va probando a ver si se pueden hacer las acciones de la izquierda.
Sino se prueban las de la derecha , si si se puede se baja un nivel del tree y sigues probando hasta que encuentras la accion.
Implementación sin arbol , solo con if else que definen la prioridad de comportamientos.


Calculos:
    Mirar si enemigo delante: Mirar angulo con el [dot product = V1 * V2 * cos(alpha)] del vector frontal y el de direccion al otro.
    Rotar para mirar al enemigo: El angulo lo sacas con el dot product y cos-1 de este , el eje : [cross product = ] Obtiene el vector perpendicular a dos (eje)
        NOTA: Siempre usar rotateLocal(rota con respecto a ) nunca rotate . Usar la Model-1 para pasar de coordenadas globales a locales
        model.rotateLocal(__coordenadas locales[Globales*Model-1]__)

Coordinacion de varias entidades para cumplir un objetivo:
    Algoritmo blackboard: Lanzar mensajes entre entidades ( necesito ayuda... , enemigo cerca.... atc)

Juegos:
homeworld


----------------------------

GUIs : Pintar en 2d. Primero toda las escena 3D y luego la GUI

Pintar quads
Scree space -1 -> 1
Camera(nueva) set orthografic ( near y far de -1 a 1 [Los otros creo que tambien] )
CULL_FACE = False , si no se ve el cuadrado.
DEPHT_TEST = Desactivado.

Si la GUI es de opciones ( crear tropas , desplegable tipos de tropas )
Se puede reaprobechar el arbol de escena para crear el arbol de menus.
Para enlazar lo de abrir los menus puedes usar los eventos que sube por el arbol de escena ( bubbliong)
Ancho y alto del objeto con posicion para saber si ha clickado.

Otra opcion:
inmediate GUI--
En el render GUI pintas los paneles / botones... No hace falta meshes y directamente puedes ir pintando cuadrados y

Blending (Activar) : usar transparencias para la GUI.
La vista de la escena desde otro punto de vista. Utilizar el glviewport y glsisors del render de otra camara.

Pintar algo encima de un objeto 3D:::::
Coordenada 2d de las coordenadas 3D = MVP * Posicion del avion -> Espacio 2D ( Coordenada normalizada usando el proyect vector ) -1 a 1
El tamaño del cuadrado tiene que estar asociado a la distancia (Calcular la tangente del fov )  Otra opcion es utilizar la bounding box (radio).
Picking coger un objeto de la pantalla.

--------------
STAGES: Loading -> menu -> play -> ending
En game un puntero al current_stage y todas las llamadas pasan por este