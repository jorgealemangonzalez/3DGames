testSphereInFrustrum -> Se usa para comprobar si un objecto se va a ver , si no se ve no lo pintes( No lo mandes  a gpu ). Por lo tanto comprobar en el render(De entity).
			Hay que usar el radio de la mesh ( bounding box ) para saber si se ve algun trozo o no. El centro de la caja no tiene porque ser el del objeto. ç
			Para cada vértice calculas los máximos y mínimos de cada componente(x,y,z)
			
Usar el spitfire low cuando haces render de un objeto desde lejos

OBJ parser de asignatura de infografia


---------


Collisions:
---

static_colliders : NO se mueven, así que no hay colisiones entre ellas
dynamic_colliders : Pueden colisionar entre ellas y con static_colliders

virtual onCollision(EntityCollider*) : Depende de la entidad concreta (plane, island, missil, etc) se pueden programar distintas reacciones a la colisión


---------

POOL:

Bullet bullet_pull[100]

[ b | b | b | b | b |  |  |  |  |  | ... |  ]
last = 4

Cuando tiempo de vida (ttl) es menor o igual que 0, el slot está "libre"

Para optimizar, se intentan poner todas las balas activas a la izquierda. Cuando se añade una se pone en el primer slot libre (indicador a allí). Cuando se quita una se pone en su lugar la bala de más a la derecha.

update: iterar i=0 : 4
render: render de varias de golpe (no una a una)

---

Idea camara: no sería descabellado que la posición y enfoque de la camara dependiese de una model que se multiplicase
por la de la entidad. Así se obtendría la misma posición relativa respecto la entidad todo el tiempo.