testSphereInFrustrum -> Se usa para comprobar si un objecto se va a ver , si no se ve no lo pintes( No lo mandes  a gpu ). Por lo tanto comprobar en el render(De entity).
			Hay que usar el radio de la mesh ( bounding box ) para saber si se ve algun trozo o no. El centro de la caja no tiene porque ser el del objeto. ç
			Para cada vértice calculas los máximos y mínimos de cada componente(x,y,z)
			
Usar el spitfire low cuando haces render de un objeto desde lejos

OBJ parser de asignatura de infografia


---------


Collisions:
---

static_colliders : NO se mueven, así que no hay colisiones entre ellas
dynamic_colliders : Pueden colisionar entre ellas y con static_colliders

virtual onCollision(EntityCollider*) : Depende de la entidad concreta (plane, island, missil, etc) se pueden programar distintas reacciones a la colisión


---------

POOL:

Bullet bullet_pull[100]

[ b | b | b | b | b |  |  |  |  |  | ... |  ]
last = 4

Cuando tiempo de vida (ttl) es menor o igual que 0, el slot está "libre"

Para optimizar, se intentan poner todas las balas activas a la izquierda. Cuando se añade una se pone en el primer slot libre (indicador a allí). Cuando se quita una se pone en su lugar la bala de más a la derecha.

update: iterar i=0 : 4
render: render de varias de golpe (no una a una)

---

Idea camara: no sería descabellado que la posición y enfoque de la camara dependiese de una model que se multiplicase
por la de la entidad. Así se obtendría la misma posición relativa respecto la entidad todo el tiempo.


---------------
Entrega:
grafo de escena y player controller

-----
NOTA: para sacar el vector frontal de un avion
---------------

---AI---
AI controller:
    target: a quien persigue
    patruya: array de waypoints y cada vez va a uno (Patruya entre unas posiciones y otras)(Mas facil que perseguir por los lios de vectores de abajo)

    Debería valer tanto para los aliados como para los enemigos.

    Aviones de buscar y atacar , Aviones de ir a un punto y hacer algo y ya , escoltas (area de acción alrededor de una entidad)

Grafo de comportamiento (Behaviour tree):
De izquierda a derecha mas importante a menos, se va probando a ver si se pueden hacer las acciones de la izquierda.
Sino se prueban las de la derecha , si si se puede se baja un nivel del tree y sigues probando hasta que encuentras la accion.
Implementación sin arbol , solo con if else que definen la prioridad de comportamientos.


Calculos:
    Mirar si enemigo delante: Mirar angulo con el [dot product = V1 * V2 * cos(alpha)] del vector frontal y el de direccion al otro.
    Rotar para mirar al enemigo: El angulo lo sacas con el dot product y cos-1 de este , el eje : [cross product = ] Obtiene el vector perpendicular a dos (eje)
        NOTA: Siempre usar rotateLocal(rota con respecto a ) nunca rotate . Usar la Model-1 para pasar de coordenadas globales a locales
        model.rotateLocal(__coordenadas locales[Globales*Model-1]__)

Coordinacion de varias entidades para cumplir un objetivo:
    Algoritmo blackboard: Lanzar mensajes entre entidades ( necesito ayuda... , enemigo cerca.... atc)

PREGUNTAS:
    acosf y dot product van en radianes ?